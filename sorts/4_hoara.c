// Алгоритм основывается на разделении рассматриваемой части массива на две части меньшего 
// размера таким образом, что все элементы из одной части не превосходят любого элемента из 
// другой части. Для такого разделения необходимо выбирать опорный элемент. 
// Теоретически следует выбирать медиану, однако на практике руководствуются лишь 
// принципом постоянного выбора, то есть каждый раз при разбиении опорный элемент 
// выбирается из одних и тех же соображений. Как вы уже догадались, функция сортировки 
// является рекурсивной функцией (строки кода 27 и 29).

void hoarasort(double* a, int first/* 0 */, int last/* 3 */)
{
 // 3 4 5 11 92 3
 // 3 4 3 11 92 5
 // 
 // 3 4 3 5 92 11 
 // 3 3 4 5 92 11 
int i = first, j = last;// 0 , 3
double tmp, x = a[(first + last) / 2];// 5 |   92 |  4


do {
   while (a[i] < x)
     i++;// 3 | 2
   while (a[j] > x)
     j--;// 2 | 1
 
   if (i <= j) 
   {
     if (i < j)
     {
       tmp=a[i];
       a[i]=a[j];
       a[j]=tmp;
     }
     i++;
     j--;
   }
} while (i <= j);
 
if (i < last)
   hoarasort(a, i, last);// a, 3, 5 | 
if (first < j)
   hoarasort(a, first,j);// a, 0, 3
}

// void main() {
//     hoarasort(a,0,n-1);
// }